const staggeredProbCurrentFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float hbar;uniform float m;uniform sampler2D tex1;uniform sampler2D tex2;uniform sampler2D tex3;float realValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.r*tmp.a;}float imagValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.g*tmp.a;}vec2 getDivRePsi(sampler2D texPsi) {float u = realValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = realValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = realValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = realValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}vec2 getDivImPsi(sampler2D texPsi) {float u = imagValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}void main() {float rePsi = texture2D(tex2, fragTexCoord).r;float imPsi = 0.5*(texture2D(tex1, fragTexCoord).g+ texture2D(tex3, fragTexCoord).g);vec2 divRePsi = getDivRePsi(tex2);vec2 divImPsi = (getDivImPsi(tex1) + getDivImPsi(tex3))/2.0;vec2 probCurrent = (hbar/m)*(-imPsi*divRePsi + rePsi*divImPsi);fragColor = vec4(probCurrent.x, probCurrent.y, 0.0, 1.0);}`;
const diracCurrentFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float pixelW;uniform float pixelH;uniform sampler2D uTex;uniform sampler2D vTex1;uniform sampler2D vTex2;uniform vec2 staggeredOffset;vec4 multiplyBySigmaX(vec4 x) {return vec4(dot(vec4(0.0, 0.0, 1.0, 0.0), x),dot(vec4(0.0, 0.0, 0.0, 1.0), x),dot(vec4(1.0, 0.0, 0.0, 0.0), x),dot(vec4(0.0, 1.0, 0.0, 0.0), x));}vec4 multiplyBySigmaY(vec4 x) {return vec4(dot(vec4(0.0, 0.0, 0.0, 1.0), x),dot(vec4(0.0, 0.0, -1.0, 0.0), x),dot(vec4(0.0, -1.0, 0.0, 0.0), x),dot(vec4(1.0, 0.0, 0.0, 0.0), x));}vec4 multiplyBySigmaZ(vec4 x) {return vec4(dot(vec4(1.0, 0.0, 0.0, 0.0), x),dot(vec4(0.0, 1.0, 0.0, 0.0), x),dot(vec4(0.0, 0.0, -1.0, 0.0), x),dot(vec4(0.0, 0.0, 0.0, -1.0), x));}void main() {vec4 u = texture2D(uTex, fragTexCoord);vec2 offset = staggeredOffset;vec4 v1 = texture2D(vTex1, fragTexCoord + offset);vec4 v2 = texture2D(vTex2, fragTexCoord + offset);vec4 v = (v1 + v2)/2.0;vec4 current;current[0] = u[0]*u[0] + u[1]*u[1] + u[2]*u[2] + u[3]*u[3]+ v[0]*v[0] + v[1]*v[1] + v[2]*v[2] + v[3]*v[3];current[1] = dot(u, multiplyBySigmaX(v))+ dot(v, multiplyBySigmaX(u));current[2] = dot(u, multiplyBySigmaY(v))+ dot(v, multiplyBySigmaY(u));current[3] = dot(u, multiplyBySigmaZ(v))+ dot(v, multiplyBySigmaZ(u));fragColor = current;}`;
const diracProbDensityFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float pixelW;uniform float pixelH;uniform sampler2D uTex;uniform sampler2D vTex1;uniform sampler2D vTex2;void main() {vec4 u = texture2D(uTex, fragTexCoord);vec2 offset = 0.5*vec2(1.0/pixelW, 1.0/pixelH);vec4 v1 = texture2D(vTex1, fragTexCoord + offset);vec4 v2 = texture2D(vTex2, fragTexCoord + offset);vec4 v = (v1 + v2)/2.0;vec4 probs = vec4(u[0]*u[0] + u[1]*u[1], u[2]*u[2] + u[3]*u[3],v[0]*v[0] + v[1]*v[1], v[2]*v[2] + v[3]*v[3]);fragColor = probs;}`;
const diracViewFragmentSource = `
#define NAME viewFrameFragmentSource
precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float constPhase;uniform float psiBrightness;uniform float potBrightness;uniform float pixelW;uniform float pixelH;uniform float showPsi1;uniform float showPsi2;uniform float showPsi3;uniform float showPsi4;uniform sampler2D vTex1;uniform sampler2D vTex2;uniform sampler2D uTex;uniform sampler2D potTex;uniform sampler2D guiTex;uniform sampler2D vecTex;uniform int wavefuncDisplayMode;uniform int potentialDisplayMode;uniform vec3 probColour;uniform vec3 potColour;const float pi = 3.141592653589793;vec3 argumentToColour(float argVal) {float maxCol = 1.0;float minCol = 50.0/255.0;float colRange = maxCol - minCol;if (argVal <= pi/3.0 && argVal >= 0.0) {return vec3(maxCol,minCol + colRange*argVal/(pi/3.0), minCol);} else if (argVal > pi/3.0 && argVal <= 2.0*pi/3.0){return vec3(maxCol - colRange*(argVal - pi/3.0)/(pi/3.0),maxCol, minCol);} else if (argVal > 2.0*pi/3.0 && argVal <= pi){return vec3(minCol, maxCol,minCol + colRange*(argVal - 2.0*pi/3.0)/(pi/3.0));} else if (argVal < 0.0 && argVal > -pi/3.0){return vec3(maxCol, minCol,minCol - colRange*argVal/(pi/3.0));} else if (argVal <= -pi/3.0 && argVal > -2.0*pi/3.0){return vec3(maxCol + (colRange*(argVal + pi/3.0)/(pi/3.0)),minCol, maxCol);} else if (argVal <= -2.0*pi/3.0 && argVal >= -pi){return vec3(minCol,minCol - (colRange*(argVal + 2.0*pi/3.0)/(pi/3.0)), maxCol);}else {return vec3(minCol, maxCol, maxCol);}}vec3 complexToColour(float re, float im) {float argVal = atan(im, re);return argumentToColour(argVal);}void main () {vec4 gui = texture2D(guiTex, fragTexCoord);vec4 vec = texture2D(vecTex, fragTexCoord);vec2 offset = 0.5*vec2(1.0/pixelW, 1.0/pixelH);vec4 u = texture2D(uTex, fragTexCoord);vec4 v1 = texture2D(vTex1, fragTexCoord + offset);vec4 v2 = texture2D(vTex2, fragTexCoord + offset);vec4 v = (v1 + v2)/2.0;vec4 probs = vec4(showPsi1*(u[0]*u[0] + u[1]*u[1]),showPsi2*(u[2]*u[2] + u[3]*u[3]),showPsi3*(v[0]*v[0] + v[1]*v[1]),showPsi4*(v[2]*v[2] + v[3]*v[3]));float potVal = texture2D(potTex, fragTexCoord).r;vec4 potPix;if (potentialDisplayMode == 0) {vec3 pot = potVal*potColour;potPix = vec4(10.0*potBrightness*pot/1000.0, 1.0);} else if (potentialDisplayMode == 1) {float val = -3.0*pi*10.0*potBrightness*potVal/1000.0 - 2.0*pi/3.0;if (val < -pi) {val = 2.0*pi + val;if (val < -pi/4.0) {val = -pi/4.0;}}vec3 pot = complexToColour(cos(val), sin(val));potPix = vec4(pot, 1.0);}vec3 col;vec4 notPhaseProb;vec4 phaseProb;vec3 ones = vec3(1.0, 1.0, 1.0);if (wavefuncDisplayMode == 0) {col = complexToColour(u[0]*cos(constPhase) - u[1]*sin(constPhase),u[0]*sin(constPhase) + u[1]*cos(constPhase));notPhaseProb = vec4((probs[1] + probs[2] + probs[3])*ones, 1.0);phaseProb = vec4(probs[0]*col, 1.0);} else if (wavefuncDisplayMode == 1) {col = complexToColour(u[2]*cos(constPhase) - u[3]*sin(constPhase),u[2]*sin(constPhase) + u[3]*cos(constPhase));notPhaseProb = vec4((probs[0] + probs[2] + probs[3])*ones, 1.0);phaseProb = vec4(probs[1]*col, 1.0);} else if (wavefuncDisplayMode == 2) {col = complexToColour(v[0]*cos(constPhase) - v[1]*sin(constPhase),v[0]*sin(constPhase) + v[1]*cos(constPhase));notPhaseProb = vec4((probs[0] + probs[1] + probs[3])*ones, 1.0);phaseProb = vec4(probs[2]*col, 1.0);} else if (wavefuncDisplayMode == 3) {col = complexToColour(v[2]*cos(constPhase) - v[3]*sin(constPhase),v[2]*sin(constPhase) + v[3]*cos(constPhase));notPhaseProb = vec4((probs[0] + probs[1] + probs[2])*ones, 1.0);phaseProb = vec4(probs[3]*col, 1.0);} else if (wavefuncDisplayMode == 4) {float pi = 3.141592653589793;float p1 = probs[0] + probs[1];float p2 = probs[2] + probs[3];float a = p1 + p2;col = complexToColour(sqrt(p1)*cos(6.0*pi/5.0)- sqrt(p2)*sin(6.0*pi/5.0),sqrt(p1)*sin(6.0*pi/5.0)+ sqrt(p2)*cos(6.0*pi/5.0));notPhaseProb = vec4(0.0, 0.0, 0.0, 1.0);phaseProb = vec4(a*col, 1.0);} else if (wavefuncDisplayMode == 5) {notPhaseProb = vec4((probs[0] + probs[1]+ probs[2] + probs[3])*probColour, 1.0);phaseProb = vec4(0.0, 0.0, 0.0, 1.0);}vec4 pixColor;if (wavefuncDisplayMode < 6) {pixColor = psiBrightness*(phaseProb + notPhaseProb)+ potPix;} else {float val = -pi*psiBrightness*(probs[0] + probs[1]+ probs[2] + probs[3])/2.0 - 2.0*pi/3.0;if (val < -pi) {val = 2.0*pi + val;if (val < 0.0) {val = 0.0;}}vec3 col = min((probs[0] + probs[1]+ probs[2] + probs[3])*(psiBrightness), 1.25)*argumentToColour(val);pixColor = vec4(col, 0.0) + potPix;}fragColor = vec4(pixColor.rgb, 1.0) + gui + vec;}`;
const vertexShaderSource = `
#if __VERSION__ == 300
in vec3 pos;out highp vec2 fragTexCoord;
#else
attribute vec3 pos;varying highp vec2 fragTexCoord;
#endif
void main() {gl_Position = vec4(pos.xyz, 1.0);fragTexCoord = vec2(0.5, 0.5) + pos.xy/2.0;}`;
const probCurrentFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float hbar;uniform float m;uniform sampler2D tex;float realValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.r*tmp.a;}float imagValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.g*tmp.a;}vec2 getDivRePsi(sampler2D texPsi) {float u = realValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = realValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = realValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = realValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}vec2 getDivImPsi(sampler2D texPsi) {float u = imagValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}void main() {float rePsi = texture2D(tex, fragTexCoord).r;float imPsi = texture2D(tex, fragTexCoord).g;vec2 divRePsi = getDivRePsi(tex);vec2 divImPsi = getDivImPsi(tex);vec2 probCurrent = (hbar/m)*(-imPsi*divRePsi + rePsi*divImPsi);fragColor = vec4(probCurrent.x, probCurrent.y, 0.0, 1.0);}`;
const curlFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float w;uniform float h;uniform sampler2D tex;uniform int type;int FOWARD = 0;int CENTRED = 1;int BACKWARD = 2;void main() {vec4 u, d, l, r;if (type == FOWARD) {/*vec4 cc = texture2D(tex, fragTexCoord);vec4 rc = texture2D(tex, fragTexCoord + vec2(dx/w, 0.0));vec4 cu = texture2D(tex, fragTexcoord + vec2(0.0, dy/h));vec4 ru = texture2D(tex, fragTexcoord + vec2(dx/w, dy/h));vec4 u = (cu + ru)/2.0;vec4 d = (cc + rc)/2.0;vec4 l = (cc + cu)/2.0;vec4 r = (ru + rc)/2.0;*/vec4 u = texture2D(tex, fragTexCoord + vec2(0.5*dx/w, dy/h));vec4 d = texture2D(tex, fragTexCoord + vec2(0.5*dx/w, 0.0));vec4 l = texture2D(tex, fragTexCoord + vec2(0.0, 0.5*dy/h));vec4 r = texture2D(tex, fragTexCoord + vec2(dx/w, 0.5*dy/h));} else if (type == CENTRED) {vec4 u = 0.5*texture2D(tex, fragTexCoord + vec2(0.0, dy/h));vec4 d = 0.5*texture2D(tex, fragTexCoord + vec2(0.0, -dy/h));vec4 l = 0.5*texture2D(tex, fragTexCoord + vec2(-dx/w, 0.0));vec4 r = 0.5*texture2D(tex, fragTexCoord + vec2(dx/w, 0.0));} else if (type == BACKWARD) {vec4 u = texture2D(tex, fragTexCoord + vec2(-0.5*dx/w, 0.0));vec4 d = texture2D(tex, fragTexCoord + vec2(-0.5*dx/w, -dy/h));vec4 l = texture2D(tex, fragTexCoord + vec2(-dx/w, -0.5*dy/h));vec4 r = texture2D(tex, fragTexCoord + vec2(0.0, -0.5*dy/h));}vec4 dAdx = (r - l)/dx;vec4 dAdy = (u - d)/dy;vec3 curl = vec3(dAdy.z, -dAdx.z, dAdx.y - dAdy.x);fragColor = vec4(curl, 1.0);}`;
const initialPotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform int potentialType;uniform int dissipativePotentialType;uniform float a;uniform float y0;uniform float w;uniform float spacing;uniform float x1;uniform float x2;uniform float aImag;
#define SHO 1
#define DOUBLE_SLIT 2
#define SINGLE_SLIT 3
#define STEP 4
#define INV_R 5
#define TRIPLE_SLIT 6
#define NEG_INV_R 7
#define CIRCLE 8
#define LOG_R 9
#define CONE 10

#define NO_DISSIPATION 0
#define BOUNDARY_DISSIPATION 1
#define UNIFORM_DISSIPATION 2
void main() {float x = fragTexCoord.x;float y = fragTexCoord.y;float imagVal = 0.0;if (dissipativePotentialType == BOUNDARY_DISSIPATION) {imagVal -= 30.0*exp(-0.5*y*y/(0.01*0.01));imagVal -= 30.0*exp(-0.5*(y-1.0)*(y-1.0)/(0.01*0.01));imagVal -= 30.0*exp(-0.5*x*x/(0.01*0.01));imagVal -= 30.0*exp(-0.5*(x-1.0)*(x-1.0)/(0.01*0.01));} else if (dissipativePotentialType == UNIFORM_DISSIPATION) {imagVal = -10.0;}if (potentialType == SHO) {fragColor = vec4(a*((x-0.5)*(x-0.5) + (y-0.5)*(y-0.5)), 0.0,imagVal, 1.0);} else if (potentialType == DOUBLE_SLIT) {if (y <= (y0 + w/2.0) &&y >= (y0 - w/2.0) &&(x <= x1 - spacing/2.0 ||(x >= x1 + spacing/2.0 &&x <= x2 - spacing/2.0) || x >= x2 + spacing/2.0)) {fragColor = vec4(a, 0.0, imagVal, 1.0);} else {fragColor = vec4(0.0, 0.0, imagVal, 1.0);}} else if (potentialType == SINGLE_SLIT) {if (y <= (y0 + w/2.0) &&y >= (y0 - w/2.0) &&(x <= x1 - spacing/2.0 ||x >= x1 + spacing/2.0)) {fragColor = vec4(a, 0.0, imagVal, 1.0);} else {fragColor = vec4(0.0, 0.0, imagVal, 1.0);}} else if (potentialType == STEP) {if (y > y0) {fragColor = vec4(a, 0.0, imagVal, 1.0);} else {fragColor = vec4(0.0, 0.0, imagVal, 1.0);}} else if (potentialType == INV_R) {float u = 10.0*(x - 0.5);float v = 10.0*(y - 0.5);float oneOverR = 1.0/sqrt(u*u + v*v);float val = (oneOverR < 50.0)? oneOverR: 50.0;fragColor = vec4(val, 0.0, imagVal, 1.0);} else if (potentialType == TRIPLE_SLIT) {float val = 15.0;if ((y <= 0.45 || y >= 0.48) || (x > 0.49 && x < 0.51)|| (x > 0.43 && x < 0.45) || (x > 0.55 && x < 0.57)) {fragColor = vec4(0.0, 0.0, imagVal, 1.0);} else {fragColor = vec4(val, 0.0, imagVal, 1.0);}} else if (potentialType == NEG_INV_R) {float u = x - 0.5;float v = y - 0.5;float oneOverR = -a/sqrt(u*u + v*v);fragColor = vec4(oneOverR + 7.0, 0.0, imagVal, 1.0);} else if (potentialType == LOG_R) {float u = x - 0.5;float v = y - 0.5;float logR = log(sqrt(u*u + v*v));fragColor = vec4(logR + 10.0, 0.0, imagVal, 1.0);} else if (potentialType == CONE) {float u = x - 0.5;float v = y - 0.5;fragColor = vec4(a*sqrt(u*u + v*v), 0.0, imagVal, 1.0);} else if (potentialType == CIRCLE) {float u = x - 0.5;float v = y - 0.5;float r = sqrt(u*u + v*v);float val = a*smoothstep(spacing - 0.02,spacing + 0.02, r);fragColor = vec4(val, 0.0, imagVal, 1.0);} else {fragColor = vec4(0.0, 0.0, imagVal, 1.0);}}`;
const initialUpperSpinorFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float bx;uniform float by;uniform float kx;uniform float ky;uniform float sx;uniform float sy;uniform float amp;uniform float pixelW;uniform float pixelH;uniform float t;uniform float hbar;uniform vec4 initSpinor;float sqrt2 = 1.4142135623730951;float pi = 3.141592653589793;
#define complex vec2
complex mult(complex z1, complex z2) {return complex(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}complex conj(complex z) {return vec2(z.x, -z.y);}void main () {float x = fragTexCoord.x;float y = fragTexCoord.y;float u = ((x - bx)/(sx*sqrt2));float v = ((y - by)/(sy*sqrt2));float re = amp*exp(- u*u - v*v)*cos(2.0*pi*(kx*x + ky*y));float im = amp*exp(- u*u - v*v)*sin(2.0*pi*(kx*x + ky*y));if ((kx == 0.0 && ky == 0.0)) {fragColor = vec4(re, im, 0.0, 0.0);} else {fragColor = vec4(mult(initSpinor.xy, complex(re, im)),mult(initSpinor.zw, complex(re, im)));}}`;
const iswEnergyEigenstatesFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
const float pi = 3.141592653589793;uniform float m;uniform float hbar;uniform float w;uniform float h;uniform float t;void main() {vec2 psi = vec2(0.0, 0.0);float E;float psin0;float x = fragTexCoord.x;float y = fragTexCoord.y;gl_FragColor = vec4(psi, 0.0, 1.0);}`;
const initialWavepacketFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float bx;uniform float by;uniform float px;uniform float py;uniform float sx;uniform float sy;uniform float amp;uniform float borderAlpha;float sqrt2 = 1.4142135623730951;float sqrtpi = 1.7724538509055159;float pi = 3.141592653589793;void main () {if (fragTexCoord.x > dx && fragTexCoord.x < 1.0-dx &&fragTexCoord.y > dy && fragTexCoord.y < 1.0-dy) {float x = fragTexCoord.x;float y = fragTexCoord.y;float u = ((x - bx)/(sx*sqrt2));float v = ((y - by)/(sy*sqrt2));float re = amp*exp(- u*u - v*v)*cos(2.0*pi*(px*x + py*y));float im = amp*exp(- u*u - v*v)*sin(2.0*pi*(px*x + py*y));fragColor = vec4(re, im, 0.0, 1.0);} else {fragColor = vec4(0.0, 0.0, 0.0, borderAlpha);}}`;
const copyOverFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex1;uniform sampler2D tex2;void main () {vec4 col1 = texture2D(tex1, fragTexCoord);vec4 col2 = texture2D(tex2, fragTexCoord);fragColor = vec4(col1.rgb + col2.rgb, 1.0);}`;
const staggeredProbDensityFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex1;uniform sampler2D tex2;uniform sampler2D tex3;void main() {vec4 col1 = texture2D(tex1, fragTexCoord);vec4 col2 = texture2D(tex2, fragTexCoord);vec4 col3 = texture2D(tex3, fragTexCoord);float probDensity = col2.r*col2.r + col1.g*col3.g;fragColor = vec4(probDensity, 0.0, 0.0, 1.0);}`;
const initialVectorPotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform int potentialType;uniform float cx;uniform float cy;
#define UNIFORM_MAGNETIC 1
void main() {float x = fragTexCoord.x;float y = fragTexCoord.y;if (potentialType == UNIFORM_MAGNETIC) {fragColor = vec4(cx*(y - 0.5), -cy*(x - 0.5), 0.0, 1.0);} else {fragColor = vec4(0.0, 0.0, 0.0, 1.0);}}`;
const realTimestepFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi;uniform sampler2D texV;uniform int laplacePoints;const int FIVE_POINT = 5;const int NINE_POINT_I = 9;const int NINE_POINT_II = 10;const int THIRTEEN_POINT = 13;const int SEVENTEEN_POINT = 17;float imagValueAt(vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.g*tmp.a;}float getDiv2ImPsi(float imPsi) {float u = imagValueAt(fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*imPsi)/(dx*dx);} else if (laplacePoints <= NINE_POINT_I) {float ul = imagValueAt(fragTexCoord + vec2(-dx/w, dy/h));float ur = imagValueAt(fragTexCoord + vec2(dx/w, dy/h));float dl = imagValueAt(fragTexCoord + vec2(-dx/w, -dy/h));float dr = imagValueAt(fragTexCoord + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*imPsi)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = imagValueAt(fragTexCoord + d00);float s01 = imagValueAt(fragTexCoord + d01);float s02 = imagValueAt(fragTexCoord + d02);float s03 = imagValueAt(fragTexCoord + d03);float s04 = imagValueAt(fragTexCoord + d04);float s10 = imagValueAt(fragTexCoord + d10);float s11 = imagValueAt(fragTexCoord + d11);float s12 = imagValueAt(fragTexCoord + d12);float s13 = imagValueAt(fragTexCoord + d13);float s14 = imagValueAt(fragTexCoord + d14);float s20 = imagValueAt(fragTexCoord + d20);float s21 = imagValueAt(fragTexCoord + d21);float s22 = imagValueAt(fragTexCoord + d22);float s23 = imagValueAt(fragTexCoord + d23);float s24 = imagValueAt(fragTexCoord + d24);float s30 = imagValueAt(fragTexCoord + d30);float s31 = imagValueAt(fragTexCoord + d31);float s32 = imagValueAt(fragTexCoord + d32);float s33 = imagValueAt(fragTexCoord + d33);float s34 = imagValueAt(fragTexCoord + d34);float s40 = imagValueAt(fragTexCoord + d40);float s41 = imagValueAt(fragTexCoord + d41);float s42 = imagValueAt(fragTexCoord + d42);float s43 = imagValueAt(fragTexCoord + d43);float s44 = imagValueAt(fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}void main () {float V = (1.0 - rScaleV)*texture2D(texV, fragTexCoord).r +rScaleV*texture2D(texV, fragTexCoord).g;float imV = texture2D(texV, fragTexCoord).b;vec4 psi = texture2D(texPsi, fragTexCoord);float rePsi = psi.r;float imPsi = psi.g;float alpha = psi.a;float div2ImPsi = getDiv2ImPsi(imPsi);float hamiltonImPsi = -(0.5*hbar*hbar/m)*div2ImPsi + V*imPsi;float f1 = 1.0 - dt*imV/hbar;float f2 = 1.0 + dt*imV/hbar;fragColor = vec4(rePsi*(f2/f1) + hamiltonImPsi*dt/(f1*hbar), imPsi,0.0, alpha);}`;
const diracSplitStepPotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D uTex;uniform sampler2D vTex;uniform sampler2D potTex;uniform int useVecPot;uniform sampler2D vecPotTex;uniform float dt;uniform float m;uniform float c;uniform float hbar;uniform int topOrBottom;const int TOP = 0;const int BOTTOM = 1;
#define complex vec2
const complex ZERO = complex(0.0, 0.0);complex mult(complex z1, complex z2) {return complex(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}complex conj(complex z) {return complex(z.x, -z.y);}complex frac(complex z1, complex z2) {complex invZ2 = conj(z2)/(z2.x*z2.x + z2.y*z2.y);return mult(z1, invZ2);}complex complexExp(complex z) {return complex(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));}complex complexCosh(complex z) {return (complexExp(z) + complexExp(-z))/2.0;}complex complexSinh(complex z) {return (complexExp(z) - complexExp(-z))/2.0;}void main() {vec4 potential = texture2D(potTex, fragTexCoord);float reV = potential[0];float imV = potential[2];float imArg = -0.5*c*reV*dt/hbar;float reArg = 0.5*c*imV*dt/hbar;if (useVecPot == 0) {fragColor = vec4(exp(reArg)*cos(imArg), exp(reArg)*sin(imArg),exp(reArg)*cos(imArg), exp(reArg)*sin(imArg));} else if (useVecPot == 1) {vec4 vecPot = texture2D(vecPotTex, fragTexCoord);float vx = vecPot.x, vy = vecPot.y, vz = vecPot.z;float v2 = vx*vx + vy*vy + vz*vz;float v = sqrt(v2);complex a, b;complex d = complex(0.0, 1.0)*dt*c/hbar;complex expV00 = complexCosh(d*v);complex expV01 = ZERO;complex expV02 = mult(vz*d, frac(complexSinh(d*v), d*v));a = complex(-vx, vy) + mult(complex(vx, -vy), complexExp(2.0*d*v));b = complexExp(-d*v);complex expV03 = 0.5*mult(a, b)/v;complex expV10 = ZERO;complex expV11 = complexCosh(d*v);a = complex(-vx, -vy) + mult(complex(vx, vy), complexExp(2.0*d*v));b = complexExp(-d*v);complex expV12 = 0.5*mult(a, b)/v;complex expV13 = mult(-vz*d, frac(complexSinh(d*v), d*v));complex expV20 = mult(vz*d, frac(complexSinh(d*v), d*v2));a = complex(-vx, vy) + mult(complex(vx, -vy), complexExp(2.0*d*v));b = complexExp(-d*v);complex expV21 = 0.5*mult(a, b)/v;complex expV22 = complexCosh(d*v);complex expV23 = ZERO;a = complex(-vx, -vy) + mult(complex(vx, vy), complexExp(2.0*d*v));b = complexExp(-d*v);complex expV30 = 0.5*mult(a, b)/v;complex expV31 = -vz*mult(d*v, frac(complexSinh(d*v), d*v2));complex expV32 = ZERO;complex expV33 = complexCosh(d*v);complex expV = complexExp(complex(reArg, imArg));vec4 upperSpinor = texture2D(uTex, fragTexCoord);vec4 lowerSpinor = texture2D(vTex, fragTexCoord);complex r0 = upperSpinor.xy;complex r1 = upperSpinor.zw;complex r2 = lowerSpinor.xy;complex r3 = lowerSpinor.zw;complex s0 = mult(expV00, r0) + mult(expV01, r1)+ mult(expV02, r2) + mult(expV03, r3);complex s1 = mult(expV10, r0) + mult(expV11, r1)+ mult(expV12, r2) + mult(expV13, r3);complex s2 = mult(expV20, r0) + mult(expV21, r1)+ mult(expV22, r2) + mult(expV23, r3);complex s3 = mult(expV30, r0) + mult(expV31, r1)+ mult(expV32, r2) + mult(expV33, r3);if (topOrBottom == TOP) {fragColor = vec4(mult(s0, expV), mult(s1, expV));} else {fragColor = vec4(mult(s2, expV), mult(s3, expV));}}}`;
const probDensityFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex;void main() {vec4 col = texture2D(tex, fragTexCoord);float probDensity = col.r*col.r + col.g*col.g;fragColor = vec4(probDensity, 0.0, 0.0, 1.0);}`;
const poissonJacobiIterFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float bScale;uniform int laplacianType;uniform sampler2D bTex;uniform sampler2D prevTex;const int FIVE_POINT = 5;const int NINE_POINT = 9;void main() {vec4 u = texture2D(prevTex, fragTexCoord + vec2(0.0, dy/h));vec4 d = texture2D(prevTex, fragTexCoord + vec2(0.0, -dy/h));vec4 l = texture2D(prevTex, fragTexCoord + vec2(-dx/w, 0.0));vec4 r = texture2D(prevTex, fragTexCoord + vec2(dx/w, 0.0));vec4 b = texture2D(bTex, fragTexCoord);if (laplacianType <= FIVE_POINT) {fragColor = bScale*b*dx*dx/4.0 + (u + d + l + r)/4.0;} else {vec4 ul = texture2D(prevTex, fragTexCoord + vec2(-dx/w, dy/h));vec4 ur = texture2D(prevTex, fragTexCoord + vec2(dx/w, dy/h));vec4 dl = texture2D(prevTex, fragTexCoord + vec2(-dx/w, -dy/h));vec4 dr = texture2D(prevTex, fragTexCoord + vec2(dx/w, -dy/h));fragColor = -(-bScale*b*dx*dx - (u + d + l + r)/2.0- (ul + ur + dl + dr)/4.0)/3.0;}}`;
const reshapePotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex1;uniform int drawMode;uniform int eraseMode;uniform float drawWidth;uniform float drawHeight;uniform float bx;uniform float by;uniform float v2;
#define DRAW_SQUARE 0
#define DRAW_CIRCLE 1
#define DRAW_GAUSS 2
void main() {vec2 xy = fragTexCoord.xy;float initialV = texture2D(tex1, fragTexCoord).r;float imagV = 0.0;float drawW2 = drawWidth*drawWidth;float drawH2 = drawHeight*drawHeight;float x2 = (xy.x - bx)*(xy.x - bx);float y2 = (xy.y - by)*(xy.y - by);if (initialV < v2 || eraseMode == 1) {if ((drawMode == DRAW_SQUARE &&x2 < drawW2 && y2 < drawH2) ||(drawMode == DRAW_CIRCLE && x2*(drawH2/drawW2) + y2 < drawH2)) {fragColor = vec4(v2, initialV, 0.0, 1.0);} else if (drawMode == DRAW_GAUSS) {float tmp = exp(-0.25*(x2/drawW2 + y2/drawH2));if (eraseMode == 0) {fragColor = vec4(max(tmp + initialV, initialV),initialV, imagV, 1.0);} else {fragColor = vec4(max(initialV - tmp, 0.0),initialV, imagV, 1.0);}} else {fragColor = vec4(initialV, initialV, imagV, 1.0);}} else {fragColor = vec4(initialV, initialV, imagV, 1.0);}}`;
const diracSplitStepKineticFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D uTex;uniform sampler2D vTex;uniform sampler2D momentumTex;uniform float dt;uniform float m;uniform float c;uniform float hbar;uniform int topOrBottom;const int TOP = 0;const int BOTTOM = 1;
#define complex vec2
complex mult(complex z1, complex z2) {return complex(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}complex conj(complex z) {return vec2(z.x, -z.y);}void main() {vec4 momenta = texture2D(momentumTex, fragTexCoord);float px = momenta.x;float py = momenta.y;float pz = momenta.z;float p2 = momenta[3];float p = sqrt(momenta[3]);float mc = m*c;float omega = sqrt(mc*mc + p2);float den1 = p*sqrt((mc - omega)*(mc - omega) + p2);float den2 = p*sqrt((mc + omega)*(mc + omega) + p2);float   matUDag00 = pz*(mc - omega)/den1;complex matUDag01 = complex(px, -py)*(mc - omega)/den1;float   matUDag02 = p2/den1;float   matUDag03 = 0.0;complex matUDag10 = complex(px, py)*(mc - omega)/den1;float   matUDag11 = -pz*(mc - omega)/den1;float   matUDag12 = 0.0;float   matUDag13 = p2/den1;float   matUDag20 = pz*(mc + omega)/den2;complex matUDag21 = complex(px, -py)*(mc + omega)/den2;float   matUDag22 = p2/den2;float   matUDag23 = 0.0;complex matUDag30 = complex(px, py)*(mc + omega)/den2;float   matUDag31 = -pz*(mc + omega)/den2;float   matUDag32 = 0.0;float   matUDag33 = p2/den2;float   matU00 = matUDag00;complex matU01 = conj(matUDag10);float   matU02 = matUDag20;complex matU03 = conj(matUDag30);complex matU10 = conj(matUDag01);float   matU11 = matUDag11;complex matU12 = conj(matUDag21);float   matU13 = matUDag31;float   matU20 = matUDag02;float   matU21 = matUDag12;float   matU22 = matUDag22;float   matU23 = matUDag32;float   matU30 = matUDag03;float   matU31 = matUDag13;float   matU32 = matUDag23;float   matU33 = matUDag33;vec4 u = texture2D(uTex, fragTexCoord);vec4 v = texture2D(vTex, fragTexCoord);complex psi0 = u.xy;complex psi1 = u.zw;complex psi2 = v.xy;complex psi3 = v.zw;float cos_val = cos(omega*c*dt/hbar);float sin_val = sin(omega*c*dt/hbar);complex e1 = complex(cos_val, sin_val);complex e2 = complex(cos_val, -sin_val);complex phi0 = matUDag00*psi0 + mult(matUDag01, psi1) + matUDag02*psi2 + matUDag03*psi3;complex phi1 = mult(matUDag10, psi0) + matUDag11*psi1 + matUDag12*psi2 + matUDag13*psi3;complex phi2 = matUDag20*psi0 + mult(matUDag21, psi1) + matUDag22*psi2 + matUDag23*psi3;complex phi3 = mult(matUDag30, psi0) + matUDag31*psi1 + matUDag32*psi2 + matUDag33*psi3;complex e1Phi0 = mult(e1, phi0);complex e1Phi1 = mult(e1, phi1);complex e2Phi2 = mult(e2, phi2);complex e2Phi3 = mult(e2, phi3);psi0 = matU00*e1Phi0 + mult(matU01, e1Phi1) + matU02*e2Phi2 + mult(matU03, e2Phi3);psi1 = mult(matU10, e1Phi0) + matU11*e1Phi1 + mult(matU12, e2Phi2) + matU13*e2Phi3;psi2 = matU20*e1Phi0 + matU21*e1Phi1 + matU22*e2Phi2 + matU23*e2Phi3;psi3 = matU30*e1Phi0 + matU31*e1Phi1 + matU32*e2Phi2 + matU33*e2Phi3;vec4 psi01 = vec4(psi0, psi1);vec4 psi23 = vec4(psi2, psi3);if (topOrBottom == TOP) {fragColor = psi01;} else if (topOrBottom == BOTTOM) {fragColor = psi23;}}`;
const bottomSpinorTimestepFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dt;uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float hbar;uniform float m;uniform float c;uniform sampler2D vTex;uniform sampler2D uTex;uniform sampler2D potTex;uniform int useVecPot;uniform sampler2D vecPotTex;vec2 mult(vec2 z1, vec2 z2) {return vec2(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}vec2 conj(vec2 z) {return vec2(z.r, -z.g);}vec4 getRightUpDownLeftAngles(vec2 xy) {float q = 1.0;vec4 centre = texture2D(vecPotTex, xy);vec4 up = texture2D(vecPotTex, xy + vec2(0.0, dy/h));vec4 down = texture2D(vecPotTex, xy + vec2(0.0, -dy/h));vec4 left = texture2D(vecPotTex, xy + vec2(-dx/w, 0.0));vec4 right = texture2D(vecPotTex, xy + vec2(dx/w, 0.0));float thetaR = 0.5*q*(right + centre).x*dx/hbar;float thetaU = 0.5*q*(up + centre).y*dy/hbar;float thetaD = -0.5*q*(centre + down).y*dy/hbar;float thetaL = -0.5*q*(centre + left).x*dx/hbar;return vec4(thetaR, thetaU, thetaD, thetaL);}vec2 getPhase(float theta) {return vec2(cos(theta), -sin(theta));}void main() {vec2 xy = fragTexCoord;vec4 rightU = texture2D(uTex, vec2(xy.x, xy.y-0.5*dy/h));vec4 leftU = texture2D(uTex, vec2(xy.x-dx/w, xy.y-0.5*dy/h));vec4 upU = texture2D(uTex, vec2(xy.x-0.5*dx/w, xy.y));vec4 downU = texture2D(uTex, vec2(xy.x-0.5*dx/w, xy.y-dy/h));if (useVecPot == 1) {vec2 loc = xy - 0.5*vec2(dx/w, dy/h);vec4 thetaRightUpDownLeft = getRightUpDownLeftAngles(loc);vec2 rightPhase = getPhase(thetaRightUpDownLeft[0]);vec2 upPhase = getPhase(thetaRightUpDownLeft[1]);vec2 downPhase = getPhase(thetaRightUpDownLeft[2]);vec2 leftPhase = getPhase(thetaRightUpDownLeft[3]);rightU = vec4(mult(rightU.rg, rightPhase),mult(rightU.ba, rightPhase));leftU = vec4(mult(leftU.rg, leftPhase),mult(leftU.ba, leftPhase));upU = vec4(mult(upU.rg, upPhase),mult(upU.ba, upPhase));downU = vec4(mult(downU.rg, downPhase),mult(downU.ba, downPhase));}vec4 dUdx = (rightU - leftU)/dx;vec4 dUdy = (upU - downU)/dy;vec4 uDerivatives = vec4(-dUdx[2] - dUdy[3], dUdy[2] - dUdx[3],-dUdx[0] + dUdy[1], -dUdy[0] - dUdx[1]);float b = 0.5*(dt/hbar)*(-m*c*c+ c*(texture2D(potTex,xy-0.5*vec2(dx/w, dy/h))[0]));float den = (1.0 + b*b);vec4 u = vec4(dot(vec4(1.0, b,  0.0, 0.0), uDerivatives)/den,dot(vec4(-b, 1.0, 0.0, 0.0), uDerivatives)/den,dot(vec4(0.0, 0.0, 1.0, b ), uDerivatives)/den,dot(vec4(0.0, 0.0, -b, 1.0), uDerivatives)/den);vec4 prevV = texture2D(vTex, xy);vec4 v = vec4(dot(vec4(1.0 - b*b, 2.0*b,  0.0, 0.0), prevV)/den,dot(vec4(-2.0*b, 1.0 - b*b, 0.0, 0.0), prevV)/den,dot(vec4(0.0, 0.0,  1.0 - b*b, 2.0*b), prevV)/den,dot(vec4(0.0, 0.0, -2.0*b, 1.0 - b*b), prevV)/den);fragColor = v + c*dt*u;}`;
const fftIterSquareFragmentSource = `/* This shader is used to implement the iterative part of theCooley-Tukey iterative radix-2 FFT algorithm. It is assumed thatthe width of the input texture is equal to its height.References:Wikipedia - Cooley–Tukey FFT algorithmhttps:MathWorld Wolfram - Fast Fourier Transform:http:William Press et al.12.2 Fast Fourier Transform (FFT) - in Numerical Recipeshttps:*/precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
#define complex vec2
#define complex2 vec4
uniform sampler2D tex;uniform float blockSize;uniform float angleSign;uniform float size;uniform float scale;uniform bool useCosTable;uniform sampler2D cosTableTex;const float PI = 3.141592653589793;const complex IMAG_UNIT = complex(0.0, 1.0);float getValueFromCosTable(float angle) {return texture2D(cosTableTex,vec2(angle/PI + 0.5/(size/2.0), 0.5)).r;}complex expI(float angle) {if (!useCosTable)return complex(cos(angle), sin(angle));float c = getValueFromCosTable(abs(angle));float s = (abs(angle) < PI/2.0)?-getValueFromCosTable(abs(angle) + PI/2.0):getValueFromCosTable(abs(angle) - PI/2.0);return complex(c, sign(angle)*s);}complex mul(complex z, complex w) {return complex(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);}complex2 c2C1(complex2 z, complex w) {return complex2(mul(z.rg, w), mul(z.ba, w));}void main() {vec2 uv = fragTexCoord;vec2 blockPosition = vec2(mod(uv[0], blockSize), mod(uv[1], blockSize));float h = blockSize/2.0;vec2 signFactor = vec2((blockPosition.x <= h)? 1.0: -1.0,(blockPosition.y <= h)? 1.0: -1.0);vec2 offset = vec2((blockPosition.x <= h)? 0.0: -1.0,(blockPosition.y <= h)? 0.0: -1.0);complex2 ee = texture2D(tex, uv + h*offset);complex2 oe = texture2D(tex, uv + h*(vec2(1.0, 0.0) + offset));complex2 eo = texture2D(tex, uv + h*(vec2(0.0, 1.0) + offset));complex2 oo = texture2D(tex, uv + h*(vec2(1.0, 1.0) + offset));vec2 angle = angleSign*2.0*PI*(blockPosition - vec2(0.5/size) + h*offset)/blockSize;complex eIAngleX = expI(angle.x);complex eIAngleY = expI(angle.y);fragColor = scale*scale*(ee+ signFactor.x*c2C1(oe, eIAngleX) + signFactor.y*c2C1(eo, eIAngleY)+ signFactor.x*signFactor.y*c2C1(oo, mul(eIAngleX, eIAngleY)));}`;
const realImagTimestepFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi1;uniform sampler2D texPsi2;uniform sampler2D texV;uniform int laplacePoints;const int FIVE_POINT = 5;const int NINE_POINT_I = 9;const int NINE_POINT_II = 10;const int THIRTEEN_POINT = 13;const int SEVENTEEN_POINT = 17;vec2 valueAt(sampler2D texPsi, vec2 coord) {vec4 psiFragment = texture2D(texPsi, coord);return psiFragment.xy*psiFragment.a;}vec2 div2Psi(sampler2D texPsi) {vec2 c = valueAt(texPsi, fragTexCoord);vec2 u = valueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));vec2 d = valueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));vec2 l = valueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));vec2 r = valueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*c)/(dx*dx);} else if (laplacePoints == NINE_POINT_I) {vec2 ul = valueAt(texPsi, fragTexCoord + vec2(-dx/w, dy/h));vec2 ur = valueAt(texPsi, fragTexCoord + vec2(dx/w, dy/h));vec2 dl = valueAt(texPsi, fragTexCoord + vec2(-dx/w, -dy/h));vec2 dr = valueAt(texPsi, fragTexCoord + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*c)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);vec2 s00 = valueAt(texPsi, fragTexCoord + d00);vec2 s01 = valueAt(texPsi, fragTexCoord + d01);vec2 s02 = valueAt(texPsi, fragTexCoord + d02);vec2 s03 = valueAt(texPsi, fragTexCoord + d03);vec2 s04 = valueAt(texPsi, fragTexCoord + d04);vec2 s10 = valueAt(texPsi, fragTexCoord + d10);vec2 s11 = valueAt(texPsi, fragTexCoord + d11);vec2 s12 = valueAt(texPsi, fragTexCoord + d12);vec2 s13 = valueAt(texPsi, fragTexCoord + d13);vec2 s14 = valueAt(texPsi, fragTexCoord + d14);vec2 s20 = valueAt(texPsi, fragTexCoord + d20);vec2 s21 = valueAt(texPsi, fragTexCoord + d21);vec2 s22 = valueAt(texPsi, fragTexCoord + d22);vec2 s23 = valueAt(texPsi, fragTexCoord + d23);vec2 s24 = valueAt(texPsi, fragTexCoord + d24);vec2 s30 = valueAt(texPsi, fragTexCoord + d30);vec2 s31 = valueAt(texPsi, fragTexCoord + d31);vec2 s32 = valueAt(texPsi, fragTexCoord + d32);vec2 s33 = valueAt(texPsi, fragTexCoord + d33);vec2 s34 = valueAt(texPsi, fragTexCoord + d34);vec2 s40 = valueAt(texPsi, fragTexCoord + d40);vec2 s41 = valueAt(texPsi, fragTexCoord + d41);vec2 s42 = valueAt(texPsi, fragTexCoord + d42);vec2 s43 = valueAt(texPsi, fragTexCoord + d43);vec2 s44 = valueAt(texPsi, fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}void main() {vec4 arrV = texture2D(texV, fragTexCoord);float V = (1.0 - rScaleV)*arrV[0] + rScaleV*arrV[1];float imV = arrV[2];float f1 = 1.0 - dt*imV/hbar;float f2 = 1.0 + dt*imV/hbar;vec4 psi1Fragment = texture2D(texPsi1, fragTexCoord);float alpha = psi1Fragment.a;vec2 psi1 = psi1Fragment.xy*alpha;vec2 psi2 = valueAt(texPsi2, fragTexCoord);vec2 hamiltonianPsi2 = -(0.5*hbar*hbar/m)*div2Psi(texPsi2) + V*psi2;fragColor = vec4(psi1.x*(f2/f1) + dt*hamiltonianPsi2.y/(f1*hbar),psi1.y*(f2/f1) - dt*hamiltonianPsi2.x/(f1*hbar),0.0, alpha);}`;
const revBitSort2FragmentSource = `/* Reverse bit sort a texture whose width and height must be a powerof two.*/precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex;uniform int width;uniform int height;bool revBitSort2SingleIter(inout int rev, inout int i,inout int asc, inout int des, int stop) {if (i/des > 0) {rev += asc;	i -= des;}des /= 2, asc *= 2;if (asc == 2*stop)return false;return true;}/* Older versions of GLSL do not support for loops.This very long function is used to reverse bit sort a finite-sizedinput texture with power of two dimensions without using any for loops.For more modern versions of GLSL a different implementation of reversebit sorting which includes for loops is used instead.*/float revBitSort2SingleDimension(int index, int size) {int rev = 0, i = index;int asc = 1, des = size/2;float retVal;if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);if (!revBitSort2SingleIter(rev, i, asc, des, size/2))retVal = (float(rev) + 0.5)/float(size);return retVal;}vec2 revBitSort2NoForLoop(vec2 uv) {int indexU = int(floor(uv[0]*float(width)));int indexV = int(floor(uv[1]*float(height)));return vec2(revBitSort2SingleDimension(indexU, width),revBitSort2SingleDimension(indexV, height));}vec2 revBitSort2(vec2 uv) {
#if (!defined(GL_ES) && __VERSION__ >= 120) || (defined(GL_ES) && __VERSION__ > 300)
vec2 uv2 = vec2(0.0, 0.0);int indexU = int(floor(uv[0]*float(width)));int indexV = int(floor(uv[1]*float(height)));int rev = 0, i = indexU;for (int asc = 1, des = width/2; des > 0; des /= 2, asc *= 2) {if (i/des > 0) {rev += asc;i -= des;}}uv2[0] = (float(rev) + 0.5)/float(width);rev = 0, i = indexV;for (int asc = 1, des = height/2; des > 0; des /= 2, asc *= 2) {if (des > i) {rev += asc;i -= des;}}uv2[1] = (float(rev) + 0.5)/float(height);return uv2;
#else
return revBitSort2NoForLoop(uv);
#endif
}void main() {fragColor = texture2D(tex, revBitSort2(fragTexCoord));}`;
const rearrangeFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float width;uniform float height;uniform sampler2D tex;uniform sampler2D lookupTex;void main() {vec2 xy = fragTexCoord;vec4 col = vec4(0.0, 0.0, 0.0, 0.0);vec2 lookupPos = texture2D(lookupTex, xy).xy;
/*#if __VERSION__ >= 130
ivec2 intLookupPos = ivec2(int(width*lookupPos.x),int(height*lookupPos.y));col += texelFetch(tex, intLookupPos, 0);
#else*/
col += texture2D(tex, lookupPos);fragColor = col;}`;
const upperSpinorTimestepFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dt;uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float hbar;uniform float m;uniform float c;uniform sampler2D vTex;uniform sampler2D uTex;uniform sampler2D potTex;uniform int useVecPot;uniform sampler2D vecPotTex;vec2 mult(vec2 z1, vec2 z2) {return vec2(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}vec2 conj(vec2 z) {return vec2(z.r, -z.g);}vec4 getRightUpDownLeftAngles(vec2 xy) {float q = 1.0;vec4 centre = texture2D(vecPotTex, xy);vec4 up = texture2D(vecPotTex, xy + vec2(0.0, dy/h));vec4 down = texture2D(vecPotTex, xy + vec2(0.0, -dy/h));vec4 left = texture2D(vecPotTex, xy + vec2(-dx/w, 0.0));vec4 right = texture2D(vecPotTex, xy + vec2(dx/w, 0.0));float thetaR = 0.5*q*(right + centre).x*dx/hbar;float thetaU = 0.5*q*(up + centre).y*dy/hbar;float thetaD = -0.5*q*(centre + down).y*dy/hbar;float thetaL = -0.5*q*(centre + left).x*dx/hbar;return vec4(thetaR, thetaU, thetaD, thetaL);}vec2 getPhase(float theta) {return vec2(cos(theta), -sin(theta));}void main() {vec2 xy = fragTexCoord;vec4 rightV = texture2D(vTex, vec2(xy.x+dx/w, xy.y+0.5*dy/h));vec4 leftV = texture2D(vTex, vec2(xy.x, xy.y+0.5*dy/h));vec4 upV = texture2D(vTex, vec2(xy.x+0.5*dx/w, xy.y+dy/h));vec4 downV = texture2D(vTex, vec2(xy.x+0.5*dx/w, xy.y));if (useVecPot == 1) {vec2 loc = xy;vec4 thetaRightUpDownLeft = getRightUpDownLeftAngles(loc);vec2 rightPhase = getPhase(thetaRightUpDownLeft[0]);vec2 upPhase = getPhase(thetaRightUpDownLeft[1]);vec2 downPhase = getPhase(thetaRightUpDownLeft[2]);vec2 leftPhase = getPhase(thetaRightUpDownLeft[3]);rightV = vec4(mult(rightV.rg, rightPhase),mult(rightV.ba, rightPhase));leftV = vec4(mult(leftV.rg, leftPhase),mult(leftV.ba, leftPhase));upV = vec4(mult(upV.rg, upPhase),mult(upV.ba, upPhase));downV = vec4(mult(downV.rg, downPhase),mult(downV.ba, downPhase));}vec4 dVdx = (rightV - leftV)/dx;vec4 dVdy = (upV - downV)/dy;vec4 vDerivatives = vec4(-dVdx[2] - dVdy[3], dVdy[2] - dVdx[3],-dVdx[0] + dVdy[1], -dVdy[0] - dVdx[1]);float a = 0.5*(dt/hbar)*(m*c*c + c*texture2D(potTex, xy)[0]);float den = (1.0 + a*a);vec4 v = vec4(dot(vec4(1.0, a,  0.0, 0.0), vDerivatives)/den,dot(vec4(-a, 1.0, 0.0, 0.0), vDerivatives)/den,dot(vec4(0.0, 0.0, 1.0, a),  vDerivatives)/den,dot(vec4(0.0, 0.0, -a, 1.0), vDerivatives)/den);vec4 prevU = texture2D(uTex, xy);vec4 u = vec4(dot(vec4(1.0 - a*a, 2.0*a,  0.0, 0.0), prevU)/den,dot(vec4(-2.0*a, 1.0 - a*a, 0.0, 0.0), prevU)/den,dot(vec4(0.0, 0.0,  1.0 - a*a, 2.0*a), prevU)/den,dot(vec4(0.0, 0.0, -2.0*a, 1.0 - a*a), prevU)/den);fragColor = u + c*dt*v;}`;
const imagTimestepFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi;uniform sampler2D texV;uniform int laplacePoints;const int FIVE_POINT = 5;const int NINE_POINT_I = 9;const int NINE_POINT_II = 10;const int THIRTEEN_POINT = 13;const int SEVENTEEN_POINT = 17;float realValueAt(vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.r*tmp.a;}float getDiv2RePsi(float rePsi) {float u = realValueAt(fragTexCoord + vec2(0.0, dy/h));float d = realValueAt(fragTexCoord + vec2(0.0, -dy/h));float l = realValueAt(fragTexCoord + vec2(-dx/w, 0.0));float r = realValueAt(fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*rePsi)/(dx*dx);} else if (laplacePoints <= NINE_POINT_I) {float ul = realValueAt(fragTexCoord + vec2(-dx/w, dy/h));float ur = realValueAt(fragTexCoord + vec2(dx/w, dy/h));float dl = realValueAt(fragTexCoord + vec2(-dx/w, -dy/h));float dr = realValueAt(fragTexCoord + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*rePsi)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = realValueAt(fragTexCoord + d00);float s01 = realValueAt(fragTexCoord + d01);float s02 = realValueAt(fragTexCoord + d02);float s03 = realValueAt(fragTexCoord + d03);float s04 = realValueAt(fragTexCoord + d04);float s10 = realValueAt(fragTexCoord + d10);float s11 = realValueAt(fragTexCoord + d11);float s12 = realValueAt(fragTexCoord + d12);float s13 = realValueAt(fragTexCoord + d13);float s14 = realValueAt(fragTexCoord + d14);float s20 = realValueAt(fragTexCoord + d20);float s21 = realValueAt(fragTexCoord + d21);float s22 = realValueAt(fragTexCoord + d22);float s23 = realValueAt(fragTexCoord + d23);float s24 = realValueAt(fragTexCoord + d24);float s30 = realValueAt(fragTexCoord + d30);float s31 = realValueAt(fragTexCoord + d31);float s32 = realValueAt(fragTexCoord + d32);float s33 = realValueAt(fragTexCoord + d33);float s34 = realValueAt(fragTexCoord + d34);float s40 = realValueAt(fragTexCoord + d40);float s41 = realValueAt(fragTexCoord + d41);float s42 = realValueAt(fragTexCoord + d42);float s43 = realValueAt(fragTexCoord + d43);float s44 = realValueAt(fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}void main () {float V = texture2D(texV, fragTexCoord).r;float imV = texture2D(texV, fragTexCoord).b;vec4 psi = texture2D(texPsi, fragTexCoord);float rePsi = psi.r;float imPsi = psi.g;float alpha = psi.a;float div2RePsi = getDiv2RePsi(rePsi);float f1 = 1.0 - dt*imV/hbar;float f2 = 1.0 + dt*imV/hbar;float hamiltonRePsi = -(0.5*hbar*hbar/m)*div2RePsi + V*rePsi;fragColor = vec4(rePsi, imPsi*(f2/f1) - hamiltonRePsi*dt/(f1*hbar),0.0, alpha);}`;
const imagePotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform int invert;uniform sampler2D tex;void main() {vec2 st = vec2(fragTexCoord.x, 1.0 - fragTexCoord.y);vec4 col = texture2D(tex, st);float avgCol = (col.r + col.g + col.b)/3.0;if (invert == 1) {avgCol = 20.0 - avgCol;}fragColor = vec4(avgCol, avgCol/2.0, 0.0, 1.0);}`;
const copyScaleFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex1;uniform sampler2D tex2;uniform float scale1;uniform float scale2;void main () {vec4 col1 = texture2D(tex1, fragTexCoord);vec4 col2 = texture2D(tex2, fragTexCoord);vec3 col = scale1*col1.rgb + scale2*col2.rgb;fragColor = vec4(col, col1.a);}`;
const viewFrameFragmentSource = `
#define NAME viewFrameFragmentSource
precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float x0;uniform float y0;uniform float w;uniform float h;uniform float lineWidth;uniform float brightness;uniform float brightness2;uniform sampler2D tex1;uniform sampler2D tex2;uniform sampler2D tex3;uniform sampler2D texV;uniform sampler2D vecTex;uniform sampler2D textTex;uniform sampler2D backgroundTex;uniform int displayMode;uniform int wavefunctionDisplayMode;uniform int potentialDisplayMode;uniform int vectorDisplayMode;uniform int backgroundDisplayMode;uniform vec3 probColour;uniform vec3 potColour;const float pi = 3.141592653589793;
#define DISPLAY_ONLY_PROB_DENSITY 0
#define DISPLAY_PHASE 1
#define DISPLAY_PROB_DENSITY_HEIGHT_MAP 2

#define DISPLAY_POTENTIAL_SINGLE_COLOUR 0
#define DISPLAY_POTENTIAL_COLOUR_MAP 1
#define DISPLAY_POTENTIAL_COLOUR 2

#define DISPLAY_NO_VECTOR 0
#define DISPLAY_VECTOR 1

#define DISPLAY_NO_BACKGROUND 0
#define DISPLAY_BACKGROUND 1
vec4 drawWindow(vec4 pix, float x, float y,float x0, float y0, float w, float h,float lineWidth) {y0 = (h < 0.0)? y0 + h: y0;h = (h < 0.0)? -h: h;x0 = (w < 0.0)? x0 + w: x0;w = (w < 0.0)? -w: w;if ((x >= x0 && x <= (x0 + w)) &&((abs(y - y0) <= lineWidth/2.0) ||(abs(y - y0 - h) <= lineWidth/2.0))) {return vec4(1.0, 1.0, 1.0, 1.0);}if ((y > y0 && y < (y0 + h)) &&((abs(x - x0) <= lineWidth/2.0) ||(abs(x - x0 - w) <= lineWidth/2.0))) {return vec4(1.0, 1.0, 1.0, 1.0);}return pix;}vec3 argumentToColour(float argVal) {float maxCol = 1.0;float minCol = 50.0/255.0;float colRange = maxCol - minCol;if (argVal <= pi/3.0 && argVal >= 0.0) {return vec3(maxCol,minCol + colRange*argVal/(pi/3.0), minCol);} else if (argVal > pi/3.0 && argVal <= 2.0*pi/3.0){return vec3(maxCol - colRange*(argVal - pi/3.0)/(pi/3.0),maxCol, minCol);} else if (argVal > 2.0*pi/3.0 && argVal <= pi){return vec3(minCol, maxCol,minCol + colRange*(argVal - 2.0*pi/3.0)/(pi/3.0));} else if (argVal < 0.0 && argVal > -pi/3.0){return vec3(maxCol, minCol,minCol - colRange*argVal/(pi/3.0));} else if (argVal <= -pi/3.0 && argVal > -2.0*pi/3.0){return vec3(maxCol + (colRange*(argVal + pi/3.0)/(pi/3.0)),minCol, maxCol);} else if (argVal <= -2.0*pi/3.0 && argVal >= -pi){return vec3(minCol,minCol - (colRange*(argVal + 2.0*pi/3.0)/(pi/3.0)), maxCol);}else {return vec3(minCol, maxCol, maxCol);}}vec3 complexToColour(float re, float im) {return argumentToColour(atan(im, re));}void main () {vec4 col1 = texture2D(tex1, fragTexCoord);vec4 col2 = texture2D(tex2, fragTexCoord);vec4 col3 = texture2D(tex3, fragTexCoord);float probDensity = (col1.g*col3.g + col2.r*col2.r);float re = col2.r;float im = (col3.g + col1.g)/2.0;vec3 wavefunction;/*vec3 colPotential = col4.r*brightness2*argumentToColour(2.0*3.14159*col4.r*brightness2 - 1.0)*exp(-brightness*probDensity/16.0);*/vec4 col4 = texture2D(texV, fragTexCoord)/(50.0*1.0);vec3 potential;if (potentialDisplayMode == DISPLAY_POTENTIAL_SINGLE_COLOUR) {potential = col4.r*brightness2*potColour;} else if (potentialDisplayMode == DISPLAY_POTENTIAL_COLOUR_MAP) {float val = -3.0*pi*col4.r*brightness2 - 2.0*pi/3.0;if (val < -pi) {val = 2.0*pi + val;if (val < -pi/4.0) {val = -pi/4.0;}}potential = argumentToColour(val);} else if (potentialDisplayMode == DISPLAY_POTENTIAL_COLOUR) {}if (wavefunctionDisplayMode == DISPLAY_PHASE) {wavefunction = probDensity*(brightness/16.0)*complexToColour(re, im);} else if (wavefunctionDisplayMode == DISPLAY_ONLY_PROB_DENSITY) {wavefunction = probDensity*probColour*(brightness/16.0);} else if (wavefunctionDisplayMode == DISPLAY_PROB_DENSITY_HEIGHT_MAP) {float val = -pi*probDensity*brightness/(4.0*10.0) - 2.0*pi/3.0;if (val < -pi) {val = 2.0*pi + val;if (val < 0.0) {val = 0.0;}}wavefunction = min(probDensity*(brightness/16.0), 1.25)*argumentToColour(val);}vec3 background;if (backgroundDisplayMode == DISPLAY_BACKGROUND) {background = texture2D(backgroundTex, fragTexCoord).rgb;}vec4 pix = vec4(wavefunction + potential + background/4.0, 1.0);if (vectorDisplayMode == DISPLAY_VECTOR) {pix += 10.0*texture2D(vecTex, fragTexCoord);}fragColor = drawWindow(pix, fragTexCoord.x, fragTexCoord.y,x0, y0, w, h, lineWidth) +texture2D(textTex, fragTexCoord);}`;
const guiRectangleFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float x0;uniform float y0;uniform float w;uniform float h;uniform float lineWidth;vec4 drawWindow(vec4 pix, float x, float y,float x0, float y0, float w, float h,float lineWidth) {y0 = (h < 0.0)? y0 + h: y0;h = (h < 0.0)? -h: h;x0 = (w < 0.0)? x0 + w: x0;w = (w < 0.0)? -w: w;if ((x >= x0 && x <= (x0 + w)) &&((abs(y - y0) <= lineWidth/2.0) ||(abs(y - y0 - h) <= lineWidth/2.0))) {return vec4(1.0, 1.0, 1.0, 1.0);}if ((y > y0 && y < (y0 + h)) &&((abs(x - x0) <= lineWidth/2.0) ||(abs(x - x0 - w) <= lineWidth/2.0))) {return vec4(1.0, 1.0, 1.0, 1.0);}return pix;}void main() {vec2 xy = fragTexCoord;vec4 col = vec4(0.0, 0.0, 0.0, 0.0);fragColor = drawWindow(col, xy.x, xy.y, x0, y0, w, h, lineWidth);}`;
const copyScaleFlipFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float scale1;uniform float scale2;uniform sampler2D tex1;uniform sampler2D tex2;void main () {vec2 coord = vec2(fragTexCoord.x, 1.0 - fragTexCoord.y);vec4 col1 = scale1*texture2D(tex1, coord);vec4 col2 = scale2*texture2D(tex2, coord);fragColor = vec4(col1.rgb + col2.rgb, 1.0);}`;
const onesFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
void main () {fragColor = vec4(1.0, 1.0, 1.0, 1.0);}`;
const complexMultiplyFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex1;uniform sampler2D tex2;uniform int layoutType;const int RE_IM_0_ALPHA2_LAYOUT = 0;const int RE_IM_RE_IM_LAYOUT = 2;void main() {vec4 col1 = texture2D(tex1, fragTexCoord);vec4 col2 = texture2D(tex2, fragTexCoord);if (layoutType == RE_IM_0_ALPHA2_LAYOUT) {fragColor = vec4(col1.r*col2.r - col1.g*col2.g,col1.r*col2.g + col1.g*col2.r, 0.0, col2.a);} else {fragColor = vec4(col1.r*col2.r - col1.g*col2.g,col1.r*col2.g + col1.g*col2.r,col1.b*col2.b - col1.a*col2.a,col1.b*col2.a + col1.a*col2.b);}}`;
const jacobiIterationFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi;uniform sampler2D texPsiIter;uniform sampler2D texV;uniform sampler2D texA;uniform int useAField;uniform int laplacePoints;const int FIVE_POINT = 5;const int NINE_POINT_I = 9;const int NINE_POINT_II = 10;const int THIRTEEN_POINT = 13;const int SEVENTEEN_POINT = 17;vec2 mult(vec2 z1, vec2 z2) {return vec2(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}vec2 conj(vec2 z) {return vec2(z.r, -z.g);}float reValueAt(sampler2D texComplexFunc, vec2 location) {vec4 tmp = texture2D(texComplexFunc, location);return tmp.r*tmp.a;}float imagValueAt(sampler2D texComplexFunc, vec2 location) {vec4 tmp = texture2D(texComplexFunc, location);return tmp.g*tmp.a;}float getImagValuesAround(sampler2D texComplexFunc) {float u = imagValueAt(texComplexFunc, fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(texComplexFunc, fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(texComplexFunc, fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(texComplexFunc, fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return u + d + l + r;} else if (laplacePoints <= NINE_POINT_I) {float ul = imagValueAt(texComplexFunc,fragTexCoord + vec2(-dx/w, dy/h));float ur = imagValueAt(texComplexFunc,fragTexCoord + vec2(dx/w, dy/h));float dl = imagValueAt(texComplexFunc,fragTexCoord + vec2(-dx/w, -dy/h));float dr = imagValueAt(texComplexFunc,fragTexCoord + vec2(dx/w, -dy/h));return 0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r;} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = imagValueAt(texComplexFunc, fragTexCoord + d00);float s01 = imagValueAt(texComplexFunc, fragTexCoord + d01);float s02 = imagValueAt(texComplexFunc, fragTexCoord + d02);float s03 = imagValueAt(texComplexFunc, fragTexCoord + d03);float s04 = imagValueAt(texComplexFunc, fragTexCoord + d04);float s10 = imagValueAt(texComplexFunc, fragTexCoord + d10);float s11 = imagValueAt(texComplexFunc, fragTexCoord + d11);float s12 = imagValueAt(texComplexFunc, fragTexCoord + d12);float s13 = imagValueAt(texComplexFunc, fragTexCoord + d13);float s14 = imagValueAt(texComplexFunc, fragTexCoord + d14);float s20 = imagValueAt(texComplexFunc, fragTexCoord + d20);float s21 = imagValueAt(texComplexFunc, fragTexCoord + d21);float s22 = imagValueAt(texComplexFunc, fragTexCoord + d22);float s23 = imagValueAt(texComplexFunc, fragTexCoord + d23);float s24 = imagValueAt(texComplexFunc, fragTexCoord + d24);float s30 = imagValueAt(texComplexFunc, fragTexCoord + d30);float s31 = imagValueAt(texComplexFunc, fragTexCoord + d31);float s32 = imagValueAt(texComplexFunc, fragTexCoord + d32);float s33 = imagValueAt(texComplexFunc, fragTexCoord + d33);float s34 = imagValueAt(texComplexFunc, fragTexCoord + d34);float s40 = imagValueAt(texComplexFunc, fragTexCoord + d40);float s41 = imagValueAt(texComplexFunc, fragTexCoord + d41);float s42 = imagValueAt(texComplexFunc, fragTexCoord + d42);float s43 = imagValueAt(texComplexFunc, fragTexCoord + d43);float s44 = imagValueAt(texComplexFunc, fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return  w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44;}}float getReValuesAround(sampler2D texComplexFunc) {float u = reValueAt(texComplexFunc, fragTexCoord + vec2(0.0, dy/h));float d = reValueAt(texComplexFunc, fragTexCoord + vec2(0.0, -dy/h));float l = reValueAt(texComplexFunc, fragTexCoord + vec2(-dx/w, 0.0));float r = reValueAt(texComplexFunc, fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return u + d + l + r;} else if (laplacePoints <= NINE_POINT_I) {float ul = reValueAt(texComplexFunc,fragTexCoord + vec2(-dx/w, dy/h));float ur = reValueAt(texComplexFunc,fragTexCoord + vec2(dx/w, dy/h));float dl = reValueAt(texComplexFunc,fragTexCoord + vec2(-dx/w, -dy/h));float dr = reValueAt(texComplexFunc,fragTexCoord + vec2(dx/w, -dy/h));return 0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r;} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = reValueAt(texComplexFunc, fragTexCoord + d00);float s01 = reValueAt(texComplexFunc, fragTexCoord + d01);float s02 = reValueAt(texComplexFunc, fragTexCoord + d02);float s03 = reValueAt(texComplexFunc, fragTexCoord + d03);float s04 = reValueAt(texComplexFunc, fragTexCoord + d04);float s10 = reValueAt(texComplexFunc, fragTexCoord + d10);float s11 = reValueAt(texComplexFunc, fragTexCoord + d11);float s12 = reValueAt(texComplexFunc, fragTexCoord + d12);float s13 = reValueAt(texComplexFunc, fragTexCoord + d13);float s14 = reValueAt(texComplexFunc, fragTexCoord + d14);float s20 = reValueAt(texComplexFunc, fragTexCoord + d20);float s21 = reValueAt(texComplexFunc, fragTexCoord + d21);float s22 = reValueAt(texComplexFunc, fragTexCoord + d22);float s23 = reValueAt(texComplexFunc, fragTexCoord + d23);float s24 = reValueAt(texComplexFunc, fragTexCoord + d24);float s30 = reValueAt(texComplexFunc, fragTexCoord + d30);float s31 = reValueAt(texComplexFunc, fragTexCoord + d31);float s32 = reValueAt(texComplexFunc, fragTexCoord + d32);float s33 = reValueAt(texComplexFunc, fragTexCoord + d33);float s34 = reValueAt(texComplexFunc, fragTexCoord + d34);float s40 = reValueAt(texComplexFunc, fragTexCoord + d40);float s41 = reValueAt(texComplexFunc, fragTexCoord + d41);float s42 = reValueAt(texComplexFunc, fragTexCoord + d42);float s43 = reValueAt(texComplexFunc, fragTexCoord + d43);float s44 = reValueAt(texComplexFunc, fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return  w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44;}}vec2 valueAt(sampler2D texComplexFunc, vec2 location) {vec4 tmp = texture2D(texComplexFunc, location);return tmp.xy*tmp.a;}/* To approximage the vector potential, Peierls substitution is used wherevery basically the non-diagonal elements are multiplied by a phase that isdetermined by a path from the diagonal to the non-diagonal elementusing the vector potential.Feynman R., Leighton R., Sands M. (2011).The Schrödinger Equation in a Classical Context:A Seminar on Superconductivityhttps:In The Feynman Lectures on Physics: The New Millennium Edition,Volume 3, chapter 21. Basic Books.Wikipedia contributors. (2021, April 21). Peierls substitutionhttps:In Wikipedia, The Free Encyclopedia*/vec4 getAngles(vec2 location) {float q = 1.0;vec2 xy = location;vec4 c = texture2D(texA, xy);vec4 u = texture2D(texA, xy + vec2(0.0, dy/h));vec4 d = texture2D(texA, xy + vec2(0.0, -dy/h));vec4 l = texture2D(texA, xy + vec2(-dx/w, 0.0));vec4 r = texture2D(texA, xy + vec2(dx/w, 0.0));float thetaR = 0.5*q*(r + c).x*dx/hbar;float thetaU = 0.5*q*(u + c).y*dy/hbar;float thetaD = -0.5*q*(c + d).y*dy/hbar;float thetaL = -0.5*q*(c + l).x*dx/hbar;return vec4(thetaR, thetaU, thetaD, thetaL);}vec2 getPhase(float theta) {return vec2(cos(theta), -sin(theta));}vec2 getValuesAround(sampler2D texComplexFunc) {vec2 xy = fragTexCoord;vec4 theta = getAngles(xy);vec2 phaseR = getPhase(theta[0]);vec2 phaseU = getPhase(theta[1]);vec2 phaseD = getPhase(theta[2]);vec2 phaseL = getPhase(theta[3]);vec2 u = mult(valueAt(texComplexFunc, xy + vec2(0.0, dy/h)), phaseU);vec2 d = mult(valueAt(texComplexFunc, xy + vec2(0.0, -dy/h)), phaseD);vec2 l = mult(valueAt(texComplexFunc, xy + vec2(-dx/w, 0.0)), phaseL);vec2 r = mult(valueAt(texComplexFunc, xy + vec2(dx/w, 0.0)), phaseR);if (laplacePoints <= FIVE_POINT) {return u + d + l + r;} else if (laplacePoints <= NINE_POINT_I) {vec2 ul = valueAt(texComplexFunc, xy + vec2(-dx/w, dy/h));vec2 ur = valueAt(texComplexFunc, xy + vec2(dx/w, dy/h));vec2 dl = valueAt(texComplexFunc, xy + vec2(-dx/w, -dy/h));vec2 dr = valueAt(texComplexFunc, xy + vec2(dx/w, -dy/h));return 0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r;} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);vec2 s00 = valueAt(texComplexFunc, fragTexCoord + d00);vec2 s01 = valueAt(texComplexFunc, fragTexCoord + d01);vec2 s02 = valueAt(texComplexFunc, fragTexCoord + d02);vec2 s03 = valueAt(texComplexFunc, fragTexCoord + d03);vec2 s04 = valueAt(texComplexFunc, fragTexCoord + d04);vec2 s10 = valueAt(texComplexFunc, fragTexCoord + d10);vec2 s11 = valueAt(texComplexFunc, fragTexCoord + d11);vec2 s12 = valueAt(texComplexFunc, fragTexCoord + d12);vec2 s13 = valueAt(texComplexFunc, fragTexCoord + d13);vec2 s14 = valueAt(texComplexFunc, fragTexCoord + d14);vec2 s20 = valueAt(texComplexFunc, fragTexCoord + d20);vec2 s21 = valueAt(texComplexFunc, fragTexCoord + d21);vec2 s22 = valueAt(texComplexFunc, fragTexCoord + d22);vec2 s23 = valueAt(texComplexFunc, fragTexCoord + d23);vec2 s24 = valueAt(texComplexFunc, fragTexCoord + d24);vec2 s30 = valueAt(texComplexFunc, fragTexCoord + d30);vec2 s31 = valueAt(texComplexFunc, fragTexCoord + d31);vec2 s32 = valueAt(texComplexFunc, fragTexCoord + d32);vec2 s33 = valueAt(texComplexFunc, fragTexCoord + d33);vec2 s34 = valueAt(texComplexFunc, fragTexCoord + d34);vec2 s40 = valueAt(texComplexFunc, fragTexCoord + d40);vec2 s41 = valueAt(texComplexFunc, fragTexCoord + d41);vec2 s42 = valueAt(texComplexFunc, fragTexCoord + d42);vec2 s43 = valueAt(texComplexFunc, fragTexCoord + d43);vec2 s44 = valueAt(texComplexFunc, fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return  w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44;}}float getCentre() {if (laplacePoints <= FIVE_POINT) {return 1.0;} else if (laplacePoints <= NINE_POINT_I) {return 0.75;} else if (laplacePoints == NINE_POINT_II) {return 5.0/4.0;} else if (laplacePoints == THIRTEEN_POINT) {return 3.5/4.0;} else {return 3.75/4.0;}}void main() {float V = (1.0 - rScaleV)*texture2D(texV, fragTexCoord).r +rScaleV*texture2D(texV, fragTexCoord).g;vec4 psiIter = texture2D(texPsiIter, fragTexCoord);vec4 psi = texture2D(texPsi, fragTexCoord);float c1 = getCentre();float imDiag = dt*V/(2.0*hbar) + c1*hbar*dt/(m*dx*dx);if (useAField == 0) {float reInvDiag = 1.0/(1.0 + imDiag*imDiag);float imInvDiag = -imDiag/(1.0 + imDiag*imDiag);float reTmp = psi.r;reTmp -= hbar*dt/(4.0*m*dx*dx)*getImagValuesAround(texPsiIter);float imTmp = psi.g;imTmp += hbar*dt/(4.0*m*dx*dx)*getReValuesAround(texPsiIter);fragColor = vec4(reInvDiag*reTmp - imInvDiag*imTmp,imInvDiag*reTmp + reInvDiag*imTmp, 0.0, psi.a);} else {vec2 invDiag = vec2(1.0/(1.0 + imDiag*imDiag),-imDiag/(1.0 + imDiag*imDiag));vec2 I = vec2(0.0, 1.0);vec2 tmp = psi.xy + hbar*dt/(4.0*m*dx*dx)*mult(I, getValuesAround(texPsiIter));fragColor = vec4(mult(invDiag, tmp), 0.0, psi.a);}}`;
const initialBottomSpinorFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float bx;uniform float by;uniform float kx;uniform float ky;uniform float sx;uniform float sy;uniform float amp;uniform float pixelW;uniform float pixelH;uniform float t;uniform float hbar;uniform vec4 initSpinor;uniform float staggeredOffset;float sqrt2 = 1.4142135623730951;float pi = 3.141592653589793;
#define complex vec2
complex mult(complex z1, complex z2) {return complex(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}complex conj(complex z) {return vec2(z.x, -z.y);}void main () {float x = fragTexCoord.x - staggeredOffset/pixelW;float y = fragTexCoord.y - staggeredOffset/pixelH;float u = ((x - bx)/(sx*sqrt2));float v = ((y - by)/(sy*sqrt2));float re = amp*exp(- u*u - v*v)*cos(2.0*pi*(kx*x + ky*y));float im = amp*exp(- u*u - v*v)*sin(2.0*pi*(kx*x + ky*y));if ((kx == 0.0 && ky == 0.0)) {fragColor = vec4(0.0, 0.0, 0.0, 0.0);} else {fragColor = vec4(mult(initSpinor.xy, complex(re, im)),mult(initSpinor.zw, complex(re, im)));}}`;
const realImagTimestep2FragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi1;uniform sampler2D texPsi2;uniform sampler2D texV;uniform int laplacePoints;vec2 div2Psi_(sampler2D texPsi, vec2 coord) {float dw = dx/w;float dh = dy/h;vec2 uul = texture2D(texPsi, coord + vec2(-0.5*dw, 1.5*dh)).xy;vec2 uur = texture2D(texPsi, coord + vec2(0.5*dw, 1.5*dh)).xy;vec2 ul = texture2D(texPsi, coord + vec2(-0.5*dw, 0.5*dh)).xy;vec2 ull = texture2D(texPsi, coord + vec2(-1.5*dw, 0.5*dh)).xy;vec2 ur = texture2D(texPsi, coord + vec2(0.5*dw, 0.5*dh)).xy;vec2 urr = texture2D(texPsi, coord + vec2(1.5*dw, 0.5*dh)).xy;vec2 dl = texture2D(texPsi, coord + vec2(-0.5*dw, -0.5*dh)).xy;vec2 dll = texture2D(texPsi, coord + vec2(-1.5*dw, -0.5*dh)).xy;vec2 dr = texture2D(texPsi, coord + vec2(0.5*dw, -0.5*dh)).xy;vec2 drr = texture2D(texPsi, coord + vec2(1.5*dw, -0.5*dh)).xy;vec2 ddl = texture2D(texPsi, coord + vec2(-0.5*dw, -1.5*dh)).xy;vec2 ddr = texture2D(texPsi, coord + vec2(0.5*dw, -1.5*dh)).xy;vec2 d2Psidx2 = (urr - ur - ul + ull + drr - dr - dl + dll)/(4.0*dx*dx);vec2 d2Psidy2 = (uul - ul - dl + ddl + uur - ur - dr + ddr)/(4.0*dy*dy);return d2Psidx2 + d2Psidy2;}vec2 div2Psi(sampler2D texPsi, vec2 coord) {float dw = dx/w;float dh = dy/h;vec2 uu = texture2D(texPsi, coord + vec2(0.0, dh)).xy;vec2 u = texture2D(texPsi, coord + 0.5*vec2(0.0, dh)).xy;vec2 d = texture2D(texPsi, coord + 0.5*vec2(0.0, -dh)).xy;vec2 dd = texture2D(texPsi, coord + vec2(0.0, -dh)).xy;vec2 ll = texture2D(texPsi, coord + vec2(-dw, 0.0)).xy;vec2 l = texture2D(texPsi, coord + 0.5*vec2(-dw, 0.0)).xy;vec2 r = texture2D(texPsi, coord + 0.5*vec2(dw, 0.0)).xy;vec2 rr = texture2D(texPsi, coord + vec2(dw, 0.0)).xy;return 0.5*(uu - u - d + dd)/(dy*dy) + 0.5*(ll - l - r + rr)/(dx*dx);}void main() {vec2 coord1 = fragTexCoord + 0.5*vec2(dx/w, dy/h);vec2 coord2 = fragTexCoord - 0.0*vec2(dx/w, dy/h);float VR = (1.0 - rScaleV)*texture2D(texV, coord2).r +rScaleV*texture2D(texV, coord2).g;float VI = (1.0 - rScaleV)*texture2D(texV, fragTexCoord).r +rScaleV*texture2D(texV, fragTexCoord).g;vec2 psi1 = texture2D(texPsi1, fragTexCoord).xy;vec2 psi2 = texture2D(texPsi2, fragTexCoord).xy;vec2 psiR = texture2D(texPsi2, coord1).xy;vec2 psiI = texture2D(texPsi2, coord2).xy;vec2 div2PsiR = div2Psi(texPsi2, coord1);vec2 div2PsiI = div2Psi(texPsi2, coord2);vec2 hamiltonianPsiR = -(0.5*hbar*hbar/m)*div2PsiR + VR*psiR;vec2 hamiltonianPsiI = -(0.5*hbar*hbar/m)*div2PsiI + VI*psiI;fragColor = vec4(psi1.x + dt*hamiltonianPsiI.y/hbar,psi1.y - dt*hamiltonianPsiR.x/hbar,0.0, 0.0);}`;
const dist2FragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex0;uniform sampler2D tex1;uniform sampler2D tex2;void main() {vec4 v0 = texture2D(tex0, fragTexCoord);vec4 v1 = texture2D(tex1, fragTexCoord);vec4 v2 = texture2D(tex2, fragTexCoord);vec4 diff = v2 - v1;fragColor = vec4(diff.x*diff.x + diff.y*diff.y + diff.z*diff.z,v0.x*v0.x + v0.y*v0.y + v0.z*v0.z, 0.0,0.0);}`;
const probCurrent2FragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float w;uniform float h;uniform float hbar;uniform float m;uniform sampler2D tex;uniform sampler2D texA;float realValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.r*tmp.a;}float imagValueAt(sampler2D texPsi, vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.g*tmp.a;}vec2 getDivRePsi(sampler2D texPsi) {float u = realValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = realValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = realValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = realValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}vec2 getDivImPsi(sampler2D texPsi) {float u = imagValueAt(texPsi, fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(texPsi, fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(texPsi, fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(texPsi, fragTexCoord + vec2(dx/w, 0.0));return vec2(0.5*(r - l)/dx, 0.5*(u - d)/dy);}void main() {float rePsi = texture2D(tex, fragTexCoord).r;float imPsi = texture2D(tex, fragTexCoord).g;vec2 divRePsi = getDivRePsi(tex);vec2 divImPsi = getDivImPsi(tex);vec2 probCurrent = (hbar/m)*(-imPsi*divRePsi + rePsi*divImPsi);fragColor = vec4(probCurrent.x, probCurrent.y, 0.0, 1.0);}`;
const expPotentialFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D texV;uniform float dt;uniform float hbar;void main() {vec4 potential = texture2D(texV, fragTexCoord);float reV = potential[0];float imV = potential[2];float imArg = -0.5*reV*dt/hbar;float reArg = 0.5*imV*dt/hbar;fragColor = vec4(exp(reArg)*cos(imArg), exp(reArg)*sin(imArg), 0.0, 1.0);}`;
const fftIterFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform sampler2D tex;uniform float blockSize;uniform int isVertical;uniform float angleSign;uniform float size;uniform float scale;const float tau = 6.283185307179586;vec4 getOdd1(float x, float y) {return (isVertical == 0)? texture2D(tex, vec2(x + blockSize/2.0, y)):texture2D(tex, vec2(x, y + blockSize/2.0));}vec4 getEven2(float x, float y) {return (isVertical == 0)? texture2D(tex, vec2(x - blockSize/2.0, y)):texture2D(tex, vec2(x, y - blockSize/2.0));}void main() {float x = fragTexCoord.x;float y = fragTexCoord.y;float val = (isVertical == 0)? mod(x, blockSize): mod(y, blockSize);vec4 even1 = texture2D(tex, fragTexCoord);vec4 odd1 = getOdd1(x, y);float phi1 = angleSign*tau*(val - 0.5/size)/(blockSize);float cos_val1 = cos(phi1);float sin_val1 = sin(phi1);vec4 expOdd1 = vec4(odd1.r*cos_val1 - odd1.g*sin_val1,odd1.r*sin_val1 + odd1.g*cos_val1,odd1.b*cos_val1 - odd1.a*sin_val1,odd1.b*sin_val1 + odd1.a*cos_val1);vec4 out1 = scale*(even1 + expOdd1);vec4 even2 = getEven2(x, y);vec4 odd2 = texture2D(tex, fragTexCoord);float phi2 = angleSign*tau*((val - 0.5/size) - blockSize/2.0)/(blockSize);float cos_val2 = cos(phi2);float sin_val2 = sin(phi2);vec4 expOdd2 = vec4(odd2.r*cos_val2 - odd2.g*sin_val2,odd2.r*sin_val2 + odd2.g*cos_val2,odd2.b*cos_val2 - odd2.a*sin_val2,odd2.b*sin_val2 + odd2.a*cos_val2);vec4 out2 = scale*(even2 - expOdd2);fragColor = (val <= blockSize/2.0)? out1: out2;}`;
const cnExplicitPartFragmentSource = `precision highp float;
#if __VERSION__ == 300
#define texture2D texture
in vec2 fragTexCoord;out vec4 fragColor;
#else
#define fragColor gl_FragColor
varying highp vec2 fragTexCoord;
#endif
uniform float dx;uniform float dy;uniform float dt;uniform float w;uniform float h;uniform float m;uniform float hbar;uniform float rScaleV;uniform sampler2D texPsi;uniform sampler2D texV;uniform sampler2D texA;uniform int useAField;uniform int laplacePoints;const int FIVE_POINT = 5;const int NINE_POINT_I = 9;const int NINE_POINT_II = 10;const int THIRTEEN_POINT = 13;const int SEVENTEEN_POINT = 17;vec2 mult(vec2 z1, vec2 z2) {return vec2(z1.x*z2.x - z1.y*z2.y,z1.x*z2.y + z1.y*z2.x);}vec2 conj(vec2 z) {return vec2(z.r, -z.g);}float realValueAt(vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.r*tmp.a;}float imagValueAt(vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.g*tmp.a;}vec2 valueAt(vec2 location) {vec4 tmp = texture2D(texPsi, location);return tmp.xy*tmp.a;}/* To approximage the vector potential, Peierls substitution is used wherevery basically the non-diagonal elements are multiplied by a phase that isdetermined by a path from the diagonal to the non-diagonal elementusing the vector potential.Feynman R., Leighton R., Sands M. (2011).The Schrödinger Equation in a Classical Context:A Seminar on Superconductivityhttps:In The Feynman Lectures on Physics: The New Millennium Edition,Volume 3, chapter 21. Basic Books.Wikipedia contributors. (2021, April 21). Peierls substitutionhttps:In Wikipedia, The Free Encyclopedia*/vec4 getAngles(vec2 location) {float q = 1.0;vec2 xy = location;vec4 c = texture2D(texA, xy);vec4 u = texture2D(texA, xy + vec2(0.0, dy/h));vec4 d = texture2D(texA, xy + vec2(0.0, -dy/h));vec4 l = texture2D(texA, xy + vec2(-dx/w, 0.0));vec4 r = texture2D(texA, xy + vec2(dx/w, 0.0));float thetaR = 0.5*q*(r + c).x*dx/hbar;float thetaU = 0.5*q*(u + c).y*dy/hbar;float thetaD = -0.5*q*(c + d).y*dy/hbar;float thetaL = -0.5*q*(c + l).x*dx/hbar;return vec4(thetaR, thetaU, thetaD, thetaL);}vec2 getPhase(float theta) {return vec2(cos(theta), -sin(theta));}vec2 getDiv2Psi() {vec2 xy = fragTexCoord;vec4 theta = getAngles(xy);vec2 phaseR = getPhase(theta[0]);vec2 phaseU = getPhase(theta[1]);vec2 phaseD = getPhase(theta[2]);vec2 phaseL = getPhase(theta[3]);vec2 u = mult(valueAt(xy + vec2(0.0, dy/h)), phaseU);vec2 d = mult(valueAt(xy + vec2(0.0, -dy/h)), phaseD);vec2 l = mult(valueAt(xy + vec2(-dx/w, 0.0)), phaseL);vec2 r = mult(valueAt(xy + vec2(dx/w, 0.0)), phaseR);vec2 c = valueAt(xy);if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*c)/(dx*dx);} else if (laplacePoints <= NINE_POINT_I) {vec2 ul = valueAt(xy + vec2(-dx/w, dy/h));vec2 ur = valueAt(xy + vec2(dx/w, dy/h));vec2 dl = valueAt(xy + vec2(-dx/w, -dy/h));vec2 dr = valueAt(xy + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*c)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);vec2 s00 = valueAt(fragTexCoord + d00);vec2 s01 = valueAt(fragTexCoord + d01);vec2 s02 = valueAt(fragTexCoord + d02);vec2 s03 = valueAt(fragTexCoord + d03);vec2 s04 = valueAt(fragTexCoord + d04);vec2 s10 = valueAt(fragTexCoord + d10);vec2 s11 = valueAt(fragTexCoord + d11);vec2 s12 = valueAt(fragTexCoord + d12);vec2 s13 = valueAt(fragTexCoord + d13);vec2 s14 = valueAt(fragTexCoord + d14);vec2 s20 = valueAt(fragTexCoord + d20);vec2 s21 = valueAt(fragTexCoord + d21);vec2 s22 = valueAt(fragTexCoord + d22);vec2 s23 = valueAt(fragTexCoord + d23);vec2 s24 = valueAt(fragTexCoord + d24);vec2 s30 = valueAt(fragTexCoord + d30);vec2 s31 = valueAt(fragTexCoord + d31);vec2 s32 = valueAt(fragTexCoord + d32);vec2 s33 = valueAt(fragTexCoord + d33);vec2 s34 = valueAt(fragTexCoord + d34);vec2 s40 = valueAt(fragTexCoord + d40);vec2 s41 = valueAt(fragTexCoord + d41);vec2 s42 = valueAt(fragTexCoord + d42);vec2 s43 = valueAt(fragTexCoord + d43);vec2 s44 = valueAt(fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}float getDiv2RePsi(float rePsi) {float u = realValueAt(fragTexCoord + vec2(0.0, dy/h));float d = realValueAt(fragTexCoord + vec2(0.0, -dy/h));float l = realValueAt(fragTexCoord + vec2(-dx/w, 0.0));float r = realValueAt(fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*rePsi)/(dx*dx);} else if (laplacePoints <= NINE_POINT_I) {float ul = realValueAt(fragTexCoord + vec2(-dx/w, dy/h));float ur = realValueAt(fragTexCoord + vec2(dx/w, dy/h));float dl = realValueAt(fragTexCoord + vec2(-dx/w, -dy/h));float dr = realValueAt(fragTexCoord + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*rePsi)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = realValueAt(fragTexCoord + d00);float s01 = realValueAt(fragTexCoord + d01);float s02 = realValueAt(fragTexCoord + d02);float s03 = realValueAt(fragTexCoord + d03);float s04 = realValueAt(fragTexCoord + d04);float s10 = realValueAt(fragTexCoord + d10);float s11 = realValueAt(fragTexCoord + d11);float s12 = realValueAt(fragTexCoord + d12);float s13 = realValueAt(fragTexCoord + d13);float s14 = realValueAt(fragTexCoord + d14);float s20 = realValueAt(fragTexCoord + d20);float s21 = realValueAt(fragTexCoord + d21);float s22 = realValueAt(fragTexCoord + d22);float s23 = realValueAt(fragTexCoord + d23);float s24 = realValueAt(fragTexCoord + d24);float s30 = realValueAt(fragTexCoord + d30);float s31 = realValueAt(fragTexCoord + d31);float s32 = realValueAt(fragTexCoord + d32);float s33 = realValueAt(fragTexCoord + d33);float s34 = realValueAt(fragTexCoord + d34);float s40 = realValueAt(fragTexCoord + d40);float s41 = realValueAt(fragTexCoord + d41);float s42 = realValueAt(fragTexCoord + d42);float s43 = realValueAt(fragTexCoord + d43);float s44 = realValueAt(fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}float getDiv2ImPsi(float imPsi) {float u = imagValueAt(fragTexCoord + vec2(0.0, dy/h));float d = imagValueAt(fragTexCoord + vec2(0.0, -dy/h));float l = imagValueAt(fragTexCoord + vec2(-dx/w, 0.0));float r = imagValueAt(fragTexCoord + vec2(dx/w, 0.0));if (laplacePoints <= FIVE_POINT) {return (u + d + l + r - 4.0*imPsi)/(dx*dx);} else if (laplacePoints <= NINE_POINT_I) {float ul = imagValueAt(fragTexCoord + vec2(-dx/w, dy/h));float ur = imagValueAt(fragTexCoord + vec2(dx/w, dy/h));float dl = imagValueAt(fragTexCoord + vec2(-dx/w, -dy/h));float dr = imagValueAt(fragTexCoord + vec2(dx/w, -dy/h));return (0.25*ur + 0.5*u + 0.25*ul + 0.5*l +0.25*dl + 0.5*d + 0.25*dr + 0.5*r - 3.0*imPsi)/(dx*dx);} else {vec2 d00 = vec2(2.0*dx/w, 2.0*dy/h);vec2 d01 = vec2(2.0*dx/w, dy/h);vec2 d02 = vec2(2.0*dx/w, 0.0);vec2 d03 = vec2(2.0*dx/w, -1.0*dy/h);vec2 d04 = vec2(2.0*dx/w, -2.0*dy/h);vec2 d10 = vec2(dx/w, 2.0*dy/h);vec2 d11 = vec2(dx/w, dy/h);vec2 d12 = vec2(dx/w, 0.0);vec2 d13 = vec2(dx/w, -1.0*dy/h);vec2 d14 = vec2(dx/w, -2.0*dy/h);vec2 d20 = vec2(0.0, 2.0*dy/h);vec2 d21 = vec2(0.0, dy/h);vec2 d22 = vec2(0.0, 0.0);vec2 d23 = vec2(0.0, -1.0*dy/h);vec2 d24 = vec2(0.0, -2.0*dy/h);vec2 d30 = vec2(-1.0*dx/w, 2.0*dy/h);vec2 d31 = vec2(-1.0*dx/w, dy/h);vec2 d32 = vec2(-1.0*dx/w, 0.0);vec2 d33 = vec2(-1.0*dx/w, -1.0*dy/h);vec2 d34 = vec2(-1.0*dx/w, -2.0*dy/h);vec2 d40 = vec2(-2.0*dx/w, 2.0*dy/h);vec2 d41 = vec2(-2.0*dx/w, dy/h);vec2 d42 = vec2(-2.0*dx/w, 0.0);vec2 d43 = vec2(-2.0*dx/w, -1.0*dy/h);vec2 d44 = vec2(-2.0*dx/w, -2.0*dy/h);float s00 = imagValueAt(fragTexCoord + d00);float s01 = imagValueAt(fragTexCoord + d01);float s02 = imagValueAt(fragTexCoord + d02);float s03 = imagValueAt(fragTexCoord + d03);float s04 = imagValueAt(fragTexCoord + d04);float s10 = imagValueAt(fragTexCoord + d10);float s11 = imagValueAt(fragTexCoord + d11);float s12 = imagValueAt(fragTexCoord + d12);float s13 = imagValueAt(fragTexCoord + d13);float s14 = imagValueAt(fragTexCoord + d14);float s20 = imagValueAt(fragTexCoord + d20);float s21 = imagValueAt(fragTexCoord + d21);float s22 = imagValueAt(fragTexCoord + d22);float s23 = imagValueAt(fragTexCoord + d23);float s24 = imagValueAt(fragTexCoord + d24);float s30 = imagValueAt(fragTexCoord + d30);float s31 = imagValueAt(fragTexCoord + d31);float s32 = imagValueAt(fragTexCoord + d32);float s33 = imagValueAt(fragTexCoord + d33);float s34 = imagValueAt(fragTexCoord + d34);float s40 = imagValueAt(fragTexCoord + d40);float s41 = imagValueAt(fragTexCoord + d41);float s42 = imagValueAt(fragTexCoord + d42);float s43 = imagValueAt(fragTexCoord + d43);float s44 = imagValueAt(fragTexCoord + d44);float w00, w01, w02, w03, w04;float w10, w11, w12, w13, w14;float w20, w21, w22, w23, w24;float w30, w31, w32, w33, w34;float w40, w41, w42, w43, w44;if (laplacePoints == NINE_POINT_II) {w00 = 0.0, w01 = 0.0, w02 = -1./12.0, w03 = 0.0, w04 = 0.0;w10 = 0.0, w11 = 0.0, w12 = 4.0/3.0,  w13 = 0.0, w14 = 0.0;w20 = -1.0/12.0, w21 = 4.0/3.0,w22 = -5.0, w23 = 4.0/3.0, w24 = -1.0/12.0;w30 = 0.0, w31 = 0.0, w32 = 4.0/3.0,   w33 = 0.0, w34 = 0.0;w40 = 0.0, w41 = 0.0, w42 = -1.0/12.0, w43 = 0.0, w44 = 0.0;} else if (laplacePoints == THIRTEEN_POINT) {w00 = 0.0;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = 0.0;w10 = 0.0;w11 = 0.25;w12 = 0.6666666666666666;w13 = 0.25;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.5;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.25;w32 = 0.6666666666666666;w33 = 0.25;w34 = 0.0;w40 = 0.0;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = 0.0;} else {w00 = -0.020833333333333332;w01 = 0.0;w02 = -0.041666666666666664;w03 = 0.0;w04 = -0.020833333333333332;w10 = 0.0;w11 = 0.3333333333333333;w12 = 0.6666666666666666;w13 = 0.3333333333333333;w14 = 0.0;w20 = -0.041666666666666664;w21 = 0.6666666666666666;w22 = -3.75;w23 = 0.6666666666666666;w24 = -0.041666666666666664;w30 = 0.0;w31 = 0.3333333333333333;w32 = 0.6666666666666666;w33 = 0.3333333333333333;w34 = 0.0;w40 = -0.020833333333333332;w41 = 0.0;w42 = -0.041666666666666664;w43 = 0.0;w44 = -0.020833333333333332;}return (w00*s00+ w01*s01 + w02*s02 + w03*s03 + w04*s04+ w10*s10 + w11*s11 + w12*s12 + w13*s13 + w14*s14+ w20*s20 + w21*s21 + w22*s22 + w23*s23+ w24*s24 + w30*s30 + w31*s31 + w32*s32+ w33*s33 + w34*s34 + w40*s40 + w41*s41+ w42*s42 + w43*s43 + w44*s44)/(dx*dx);}}void main() {float V = (1.0 - rScaleV)*texture2D(texV, fragTexCoord).r +rScaleV*texture2D(texV, fragTexCoord).g;vec4 psi = texture2D(texPsi, fragTexCoord);if (useAField == 0) {float reKinetic = (-hbar*hbar/(2.0*m))*getDiv2RePsi(psi.r);float imKinetic = (-hbar*hbar/(2.0*m))*getDiv2ImPsi(psi.g);float hamiltonRePsi = reKinetic + V*psi.r;float hamiltonImPsi = imKinetic + V*psi.g;fragColor = vec4(psi.r + dt/(2.0*hbar)*hamiltonImPsi,psi.g - dt/(2.0*hbar)*hamiltonRePsi, 0.0, psi.a);} else {vec2 kinetic = (-hbar*hbar/(2.0*m))*getDiv2Psi();vec2 hamiltonPsi = kinetic + V*psi.xy;vec2 I = vec2(0.0, 1.0);fragColor = vec4(psi.xy - (dt/(2.0*hbar))*mult(I, hamiltonPsi), 0.0,psi.a);}}`;
